Практика #3
Если есть иерархия байтовых потоков ввода-вывода, основанная на абстрактных классах InputStream и OutputStream, то зачем дополнительные иерархии, основанные на абстрактных классах Reader и Writer?

Ответ:

Абстрактные классы Reader и Writer представляют собой иерархию потоков символов (текстовых данных), тогда как InputStream и OutputStream предназначены для потоков байтов (двоичных данных). Разделение этих иерархий основано на различиях в обработке бинарных и текстовых данных.

Основные причины для наличия дополнительных иерархий Reader и Writer:

1. Работа с символами и кодировками:
   - Reader и Writer предназначены для работы с символами (char), что упрощает обработку текста с учётом кодировок (например, UTF-8, UTF-16).
   - Байтовые потоки (InputStream и OutputStream) работают с сырыми байтами, не учитывая конкретных символов или кодировок, что требует дополнительной обработки при работе с текстовыми данными.

2. Удобство и функциональность:
   - Иерархия Reader и Writer предоставляет методы для чтения и записи символов, строк и массивов символов, что более удобно для работы с текстовыми файлами.
   - Существуют подклассы, такие как BufferedReader и BufferedWriter, которые предлагают буферизацию и дополнительные методы, например, readLine().

3. Разделение ответственности:
   - Чёткое разделение между потоками байтов и символов позволяет выбирать подходящий инструмент в зависимости от задачи, улучшая читаемость и сопровождаемость кода.

4. Поддержка различных источников и назначений данных:
   - Дополнительные иерархии позволяют создавать адаптеры, преобразующие байтовые потоки в символьные и наоборот, например, через классы InputStreamReader и OutputStreamWriter.

Пример использования BufferedReader для чтения текстового файла:
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class ReaderExample {
    public static void main(String[] args) {
        String filePath = "textfile.txt";

        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            // Читаем файл построчно
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


Преимущества использования BufferedReader и Reader:

- Буферизация: Снижает количество операций ввода-вывода, повышая эффективность.
- Методы для работы со строками: Методы вроде readLine() упрощают чтение текста построчно.
- Легкость работы с кодировками: Через InputStreamReader можно задавать нужную кодировку при преобразовании байтов в символы.

Заключение:

Иерархии InputStream/OutputStream и Reader/Writer служат разным целям: первая предназначена для работы с двоичными данными, а вторая — с текстовыми. 
Это разделение позволяет использовать наиболее подходящие средства для различных типов данных, обеспечивая гибкость и удобство при разработке приложений.
