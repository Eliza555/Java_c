Практика #2: Вызов метода `method()` объекта класса `C`

Рассмотрим следующие классы:

class A {
    int a;

    void method() {
        System.out.println("Метод method() в классе A");
    }
}

class B extends A {
    // Класс B не определяет переменную a и метод method()
}

class C extends B {
    @Override
    void method() {
        System.out.println("Метод method() в классе C");
        int a = super.a;
        super.method();
    }
}

public class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.method();
    }
}

Анализ ситуации:

1. Наследование:
   - Класс `B` наследует от класса `A` и не переопределяет ни переменную `a`, ни метод `method()`.

2. Класс `C`:
   - Наследует от класса `B`.
   - Переопределяет метод `method()`, который внутри себя:
     - Выводит сообщение.
     - Обращается к `super.a` — полю `a` из суперкласса (`A` через `B`).
     - Вызывает `super.method()` — метод `method()` из суперкласса (`A` через `B`).

Вывод программы:

Метод method() в классе C
Метод method() в классе A


Что происходит при вызове `obj.method()`:

1. **Вызов метода `method()` класса `C`:**
   - Печатает: "Метод method() в классе C".
   - Получает значение `a` из суперкласса (`A`), которое по умолчанию `0`, так как не инициализировано.
   - Вызывает метод `method()` из суперкласса (`A`), который печатает: "Метод method() в классе A".

Вывод :

Если переменная `a` и метод `method()` не определены в классе `B` и присутствуют только в классе `A`, при вызове метода `method()` объекта класса `C`:

- Метод `method()` класса `C` успешно вызывается и может обращаться к переменной `a` и методу `method()` суперкласса `A` через `super`, несмотря на отсутствие их в классе `B`.
- Компилятор всегда ищет в иерархии классов вверх по цепочке наследования до тех пор, пока не найдет соответствующую переменную или метод.
